{"ast":null,"code":"/*!\n * SmartMenus jQuery Plugin - v1.1.0 - September 17, 2017\n * http://www.smartmenus.org/\n *\n * Copyright Vasil Dinkov, Vadikom Web Ltd.\n * http://vadikom.com\n *\n * Licensed MIT\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && typeof module.exports === 'object') {\n    // CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Global jQuery\n    factory(jQuery);\n  }\n})(function ($) {\n  var menuTrees = [],\n      mouse = false,\n      // optimize for touch by default - we will detect for mouse input\n  touchEvents = 'ontouchstart' in window,\n      // we use this just to choose between toucn and pointer events, not for touch screen detection\n  mouseDetectionEnabled = false,\n      requestAnimationFrame = window.requestAnimationFrame || function (callback) {\n    return setTimeout(callback, 1000 / 60);\n  },\n      cancelAnimationFrame = window.cancelAnimationFrame || function (id) {\n    clearTimeout(id);\n  },\n      canAnimate = !!$.fn.animate; // Handle detection for mouse input (i.e. desktop browsers, tablets with a mouse, etc.)\n\n\n  function initMouseDetection(disable) {\n    var eNS = '.smartmenus_mouse';\n\n    if (!mouseDetectionEnabled && !disable) {\n      // if we get two consecutive mousemoves within 2 pixels from each other and within 300ms, we assume a real mouse/cursor is present\n      // in practice, this seems like impossible to trick unintentianally with a real mouse and a pretty safe detection on touch devices (even with older browsers that do not support touch events)\n      var firstTime = true,\n          lastMove = null,\n          events = {\n        'mousemove': function mousemove(e) {\n          var thisMove = {\n            x: e.pageX,\n            y: e.pageY,\n            timeStamp: new Date().getTime()\n          };\n\n          if (lastMove) {\n            var deltaX = Math.abs(lastMove.x - thisMove.x),\n                deltaY = Math.abs(lastMove.y - thisMove.y);\n\n            if ((deltaX > 0 || deltaY > 0) && deltaX <= 2 && deltaY <= 2 && thisMove.timeStamp - lastMove.timeStamp <= 300) {\n              mouse = true; // if this is the first check after page load, check if we are not over some item by chance and call the mouseenter handler if yes\n\n              if (firstTime) {\n                var $a = $(e.target).closest('a');\n\n                if ($a.is('a')) {\n                  $.each(menuTrees, function () {\n                    if ($.contains(this.$root[0], $a[0])) {\n                      this.itemEnter({\n                        currentTarget: $a[0]\n                      });\n                      return false;\n                    }\n                  });\n                }\n\n                firstTime = false;\n              }\n            }\n          }\n\n          lastMove = thisMove;\n        }\n      };\n\n      events[touchEvents ? 'touchstart' : 'pointerover pointermove pointerout MSPointerOver MSPointerMove MSPointerOut'] = function (e) {\n        if (isTouchEvent(e.originalEvent)) {\n          mouse = false;\n        }\n      };\n\n      $(document).on(getEventsNS(events, eNS));\n      mouseDetectionEnabled = true;\n    } else if (mouseDetectionEnabled && disable) {\n      $(document).off(eNS);\n      mouseDetectionEnabled = false;\n    }\n  }\n\n  function isTouchEvent(e) {\n    return !/^(4|mouse)$/.test(e.pointerType);\n  } // returns a jQuery on() ready object\n\n\n  function getEventsNS(events, eNS) {\n    if (!eNS) {\n      eNS = '';\n    }\n\n    var eventsNS = {};\n\n    for (var i in events) {\n      eventsNS[i.split(' ').join(eNS + ' ') + eNS] = events[i];\n    }\n\n    return eventsNS;\n  }\n\n  $.SmartMenus = function (elm, options) {\n    this.$root = $(elm);\n    this.opts = options;\n    this.rootId = ''; // internal\n\n    this.accessIdPrefix = '';\n    this.$subArrow = null;\n    this.activatedItems = []; // stores last activated A's for each level\n\n    this.visibleSubMenus = []; // stores visible sub menus UL's (might be in no particular order)\n\n    this.showTimeout = 0;\n    this.hideTimeout = 0;\n    this.scrollTimeout = 0;\n    this.clickActivated = false;\n    this.focusActivated = false;\n    this.zIndexInc = 0;\n    this.idInc = 0;\n    this.$firstLink = null; // we'll use these for some tests\n\n    this.$firstSub = null; // at runtime so we'll cache them\n\n    this.disabled = false;\n    this.$disableOverlay = null;\n    this.$touchScrollingSub = null;\n    this.cssTransforms3d = 'perspective' in elm.style || 'webkitPerspective' in elm.style;\n    this.wasCollapsible = false;\n    this.init();\n  };\n\n  $.extend($.SmartMenus, {\n    hideAll: function hideAll() {\n      $.each(menuTrees, function () {\n        this.menuHideAll();\n      });\n    },\n    destroy: function destroy() {\n      while (menuTrees.length) {\n        menuTrees[0].destroy();\n      }\n\n      initMouseDetection(true);\n    },\n    prototype: {\n      init: function init(refresh) {\n        var self = this;\n\n        if (!refresh) {\n          menuTrees.push(this);\n          this.rootId = (new Date().getTime() + Math.random() + '').replace(/\\D/g, '');\n          this.accessIdPrefix = 'sm-' + this.rootId + '-';\n\n          if (this.$root.hasClass('sm-rtl')) {\n            this.opts.rightToLeftSubMenus = true;\n          } // init root (main menu)\n\n\n          var eNS = '.smartmenus';\n          this.$root.data('smartmenus', this).attr('data-smartmenus-id', this.rootId).dataSM('level', 1).on(getEventsNS({\n            'mouseover focusin': $.proxy(this.rootOver, this),\n            'mouseout focusout': $.proxy(this.rootOut, this),\n            'keydown': $.proxy(this.rootKeyDown, this)\n          }, eNS)).on(getEventsNS({\n            'mouseenter': $.proxy(this.itemEnter, this),\n            'mouseleave': $.proxy(this.itemLeave, this),\n            'mousedown': $.proxy(this.itemDown, this),\n            'focus': $.proxy(this.itemFocus, this),\n            'blur': $.proxy(this.itemBlur, this),\n            'click': $.proxy(this.itemClick, this)\n          }, eNS), 'a'); // hide menus on tap or click outside the root UL\n\n          eNS += this.rootId;\n\n          if (this.opts.hideOnClick) {\n            $(document).on(getEventsNS({\n              'touchstart': $.proxy(this.docTouchStart, this),\n              'touchmove': $.proxy(this.docTouchMove, this),\n              'touchend': $.proxy(this.docTouchEnd, this),\n              // for Opera Mobile < 11.5, webOS browser, etc. we'll check click too\n              'click': $.proxy(this.docClick, this)\n            }, eNS));\n          } // hide sub menus on resize\n\n\n          $(window).on(getEventsNS({\n            'resize orientationchange': $.proxy(this.winResize, this)\n          }, eNS));\n\n          if (this.opts.subIndicators) {\n            this.$subArrow = $('<span/>').addClass('sub-arrow');\n\n            if (this.opts.subIndicatorsText) {\n              this.$subArrow.html(this.opts.subIndicatorsText);\n            }\n          } // make sure mouse detection is enabled\n\n\n          initMouseDetection();\n        } // init sub menus\n\n\n        this.$firstSub = this.$root.find('ul').each(function () {\n          self.menuInit($(this));\n        }).eq(0);\n        this.$firstLink = this.$root.find('a').eq(0); // find current item\n\n        if (this.opts.markCurrentItem) {\n          var reDefaultDoc = /(index|default)\\.[^#\\?\\/]*/i,\n              reHash = /#.*/,\n              locHref = window.location.href.replace(reDefaultDoc, ''),\n              locHrefNoHash = locHref.replace(reHash, '');\n          this.$root.find('a').each(function () {\n            var href = this.href.replace(reDefaultDoc, ''),\n                $this = $(this);\n\n            if (href == locHref || href == locHrefNoHash) {\n              $this.addClass('current');\n\n              if (self.opts.markCurrentTree) {\n                $this.parentsUntil('[data-smartmenus-id]', 'ul').each(function () {\n                  $(this).dataSM('parent-a').addClass('current');\n                });\n              }\n            }\n          });\n        } // save initial state\n\n\n        this.wasCollapsible = this.isCollapsible();\n      },\n      destroy: function destroy(refresh) {\n        if (!refresh) {\n          var eNS = '.smartmenus';\n          this.$root.removeData('smartmenus').removeAttr('data-smartmenus-id').removeDataSM('level').off(eNS);\n          eNS += this.rootId;\n          $(document).off(eNS);\n          $(window).off(eNS);\n\n          if (this.opts.subIndicators) {\n            this.$subArrow = null;\n          }\n        }\n\n        this.menuHideAll();\n        var self = this;\n        this.$root.find('ul').each(function () {\n          var $this = $(this);\n\n          if ($this.dataSM('scroll-arrows')) {\n            $this.dataSM('scroll-arrows').remove();\n          }\n\n          if ($this.dataSM('shown-before')) {\n            if (self.opts.subMenusMinWidth || self.opts.subMenusMaxWidth) {\n              $this.css({\n                width: '',\n                minWidth: '',\n                maxWidth: ''\n              }).removeClass('sm-nowrap');\n            }\n\n            if ($this.dataSM('scroll-arrows')) {\n              $this.dataSM('scroll-arrows').remove();\n            }\n\n            $this.css({\n              zIndex: '',\n              top: '',\n              left: '',\n              marginLeft: '',\n              marginTop: '',\n              display: ''\n            });\n          }\n\n          if (($this.attr('id') || '').indexOf(self.accessIdPrefix) == 0) {\n            $this.removeAttr('id');\n          }\n        }).removeDataSM('in-mega').removeDataSM('shown-before').removeDataSM('scroll-arrows').removeDataSM('parent-a').removeDataSM('level').removeDataSM('beforefirstshowfired').removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby').removeAttr('aria-expanded');\n        this.$root.find('a.has-submenu').each(function () {\n          var $this = $(this);\n\n          if ($this.attr('id').indexOf(self.accessIdPrefix) == 0) {\n            $this.removeAttr('id');\n          }\n        }).removeClass('has-submenu').removeDataSM('sub').removeAttr('aria-haspopup').removeAttr('aria-controls').removeAttr('aria-expanded').closest('li').removeDataSM('sub');\n\n        if (this.opts.subIndicators) {\n          this.$root.find('span.sub-arrow').remove();\n        }\n\n        if (this.opts.markCurrentItem) {\n          this.$root.find('a.current').removeClass('current');\n        }\n\n        if (!refresh) {\n          this.$root = null;\n          this.$firstLink = null;\n          this.$firstSub = null;\n\n          if (this.$disableOverlay) {\n            this.$disableOverlay.remove();\n            this.$disableOverlay = null;\n          }\n\n          menuTrees.splice($.inArray(this, menuTrees), 1);\n        }\n      },\n      disable: function disable(noOverlay) {\n        if (!this.disabled) {\n          this.menuHideAll(); // display overlay over the menu to prevent interaction\n\n          if (!noOverlay && !this.opts.isPopup && this.$root.is(':visible')) {\n            var pos = this.$root.offset();\n            this.$disableOverlay = $('<div class=\"sm-jquery-disable-overlay\"/>').css({\n              position: 'absolute',\n              top: pos.top,\n              left: pos.left,\n              width: this.$root.outerWidth(),\n              height: this.$root.outerHeight(),\n              zIndex: this.getStartZIndex(true),\n              opacity: 0\n            }).appendTo(document.body);\n          }\n\n          this.disabled = true;\n        }\n      },\n      docClick: function docClick(e) {\n        if (this.$touchScrollingSub) {\n          this.$touchScrollingSub = null;\n          return;\n        } // hide on any click outside the menu or on a menu link\n\n\n        if (this.visibleSubMenus.length && !$.contains(this.$root[0], e.target) || $(e.target).closest('a').length) {\n          this.menuHideAll();\n        }\n      },\n      docTouchEnd: function docTouchEnd(e) {\n        if (!this.lastTouch) {\n          return;\n        }\n\n        if (this.visibleSubMenus.length && (this.lastTouch.x2 === undefined || this.lastTouch.x1 == this.lastTouch.x2) && (this.lastTouch.y2 === undefined || this.lastTouch.y1 == this.lastTouch.y2) && (!this.lastTouch.target || !$.contains(this.$root[0], this.lastTouch.target))) {\n          if (this.hideTimeout) {\n            clearTimeout(this.hideTimeout);\n            this.hideTimeout = 0;\n          } // hide with a delay to prevent triggering accidental unwanted click on some page element\n\n\n          var self = this;\n          this.hideTimeout = setTimeout(function () {\n            self.menuHideAll();\n          }, 350);\n        }\n\n        this.lastTouch = null;\n      },\n      docTouchMove: function docTouchMove(e) {\n        if (!this.lastTouch) {\n          return;\n        }\n\n        var touchPoint = e.originalEvent.touches[0];\n        this.lastTouch.x2 = touchPoint.pageX;\n        this.lastTouch.y2 = touchPoint.pageY;\n      },\n      docTouchStart: function docTouchStart(e) {\n        var touchPoint = e.originalEvent.touches[0];\n        this.lastTouch = {\n          x1: touchPoint.pageX,\n          y1: touchPoint.pageY,\n          target: touchPoint.target\n        };\n      },\n      enable: function enable() {\n        if (this.disabled) {\n          if (this.$disableOverlay) {\n            this.$disableOverlay.remove();\n            this.$disableOverlay = null;\n          }\n\n          this.disabled = false;\n        }\n      },\n      getClosestMenu: function getClosestMenu(elm) {\n        var $closestMenu = $(elm).closest('ul');\n\n        while ($closestMenu.dataSM('in-mega')) {\n          $closestMenu = $closestMenu.parent().closest('ul');\n        }\n\n        return $closestMenu[0] || null;\n      },\n      getHeight: function getHeight($elm) {\n        return this.getOffset($elm, true);\n      },\n      // returns precise width/height float values\n      getOffset: function getOffset($elm, height) {\n        var old;\n\n        if ($elm.css('display') == 'none') {\n          old = {\n            position: $elm[0].style.position,\n            visibility: $elm[0].style.visibility\n          };\n          $elm.css({\n            position: 'absolute',\n            visibility: 'hidden'\n          }).show();\n        }\n\n        var box = $elm[0].getBoundingClientRect && $elm[0].getBoundingClientRect(),\n            val = box && (height ? box.height || box.bottom - box.top : box.width || box.right - box.left);\n\n        if (!val && val !== 0) {\n          val = height ? $elm[0].offsetHeight : $elm[0].offsetWidth;\n        }\n\n        if (old) {\n          $elm.hide().css(old);\n        }\n\n        return val;\n      },\n      getStartZIndex: function getStartZIndex(root) {\n        var zIndex = parseInt(this[root ? '$root' : '$firstSub'].css('z-index'));\n\n        if (!root && isNaN(zIndex)) {\n          zIndex = parseInt(this.$root.css('z-index'));\n        }\n\n        return !isNaN(zIndex) ? zIndex : 1;\n      },\n      getTouchPoint: function getTouchPoint(e) {\n        return e.touches && e.touches[0] || e.changedTouches && e.changedTouches[0] || e;\n      },\n      getViewport: function getViewport(height) {\n        var name = height ? 'Height' : 'Width',\n            val = document.documentElement['client' + name],\n            val2 = window['inner' + name];\n\n        if (val2) {\n          val = Math.min(val, val2);\n        }\n\n        return val;\n      },\n      getViewportHeight: function getViewportHeight() {\n        return this.getViewport(true);\n      },\n      getViewportWidth: function getViewportWidth() {\n        return this.getViewport();\n      },\n      getWidth: function getWidth($elm) {\n        return this.getOffset($elm);\n      },\n      handleEvents: function handleEvents() {\n        return !this.disabled && this.isCSSOn();\n      },\n      handleItemEvents: function handleItemEvents($a) {\n        return this.handleEvents() && !this.isLinkInMegaMenu($a);\n      },\n      isCollapsible: function isCollapsible() {\n        return this.$firstSub.css('position') == 'static';\n      },\n      isCSSOn: function isCSSOn() {\n        return this.$firstLink.css('display') != 'inline';\n      },\n      isFixed: function isFixed() {\n        var isFixed = this.$root.css('position') == 'fixed';\n\n        if (!isFixed) {\n          this.$root.parentsUntil('body').each(function () {\n            if ($(this).css('position') == 'fixed') {\n              isFixed = true;\n              return false;\n            }\n          });\n        }\n\n        return isFixed;\n      },\n      isLinkInMegaMenu: function isLinkInMegaMenu($a) {\n        return $(this.getClosestMenu($a[0])).hasClass('mega-menu');\n      },\n      isTouchMode: function isTouchMode() {\n        return !mouse || this.opts.noMouseOver || this.isCollapsible();\n      },\n      itemActivate: function itemActivate($a, hideDeeperSubs) {\n        var $ul = $a.closest('ul'),\n            level = $ul.dataSM('level'); // if for some reason the parent item is not activated (e.g. this is an API call to activate the item), activate all parent items first\n\n        if (level > 1 && (!this.activatedItems[level - 2] || this.activatedItems[level - 2][0] != $ul.dataSM('parent-a')[0])) {\n          var self = this;\n          $($ul.parentsUntil('[data-smartmenus-id]', 'ul').get().reverse()).add($ul).each(function () {\n            self.itemActivate($(this).dataSM('parent-a'));\n          });\n        } // hide any visible deeper level sub menus\n\n\n        if (!this.isCollapsible() || hideDeeperSubs) {\n          this.menuHideSubMenus(!this.activatedItems[level - 1] || this.activatedItems[level - 1][0] != $a[0] ? level - 1 : level);\n        } // save new active item for this level\n\n\n        this.activatedItems[level - 1] = $a;\n\n        if (this.$root.triggerHandler('activate.smapi', $a[0]) === false) {\n          return;\n        } // show the sub menu if this item has one\n\n\n        var $sub = $a.dataSM('sub');\n\n        if ($sub && (this.isTouchMode() || !this.opts.showOnClick || this.clickActivated)) {\n          this.menuShow($sub);\n        }\n      },\n      itemBlur: function itemBlur(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        }\n\n        this.$root.triggerHandler('blur.smapi', $a[0]);\n      },\n      itemClick: function itemClick(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        }\n\n        if (this.$touchScrollingSub && this.$touchScrollingSub[0] == $a.closest('ul')[0]) {\n          this.$touchScrollingSub = null;\n          e.stopPropagation();\n          return false;\n        }\n\n        if (this.$root.triggerHandler('click.smapi', $a[0]) === false) {\n          return false;\n        }\n\n        var subArrowClicked = $(e.target).is('.sub-arrow'),\n            $sub = $a.dataSM('sub'),\n            firstLevelSub = $sub ? $sub.dataSM('level') == 2 : false,\n            collapsible = this.isCollapsible(),\n            behaviorToggle = /toggle$/.test(this.opts.collapsibleBehavior),\n            behaviorLink = /link$/.test(this.opts.collapsibleBehavior),\n            behaviorAccordion = /^accordion/.test(this.opts.collapsibleBehavior); // if the sub is hidden, try to show it\n\n        if ($sub && !$sub.is(':visible')) {\n          if (!behaviorLink || !collapsible || subArrowClicked) {\n            if (this.opts.showOnClick && firstLevelSub) {\n              this.clickActivated = true;\n            } // try to activate the item and show the sub\n\n\n            this.itemActivate($a, behaviorAccordion); // if \"itemActivate\" showed the sub, prevent the click so that the link is not loaded\n            // if it couldn't show it, then the sub menus are disabled with an !important declaration (e.g. via mobile styles) so let the link get loaded\n\n            if ($sub.is(':visible')) {\n              this.focusActivated = true;\n              return false;\n            }\n          } // if the sub is visible and we are in collapsible mode\n\n        } else if (collapsible && (behaviorToggle || subArrowClicked)) {\n          this.itemActivate($a, behaviorAccordion);\n          this.menuHide($sub);\n\n          if (behaviorToggle) {\n            this.focusActivated = false;\n          }\n\n          return false;\n        }\n\n        if (this.opts.showOnClick && firstLevelSub || $a.hasClass('disabled') || this.$root.triggerHandler('select.smapi', $a[0]) === false) {\n          return false;\n        }\n      },\n      itemDown: function itemDown(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        }\n\n        $a.dataSM('mousedown', true);\n      },\n      itemEnter: function itemEnter(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        }\n\n        if (!this.isTouchMode()) {\n          if (this.showTimeout) {\n            clearTimeout(this.showTimeout);\n            this.showTimeout = 0;\n          }\n\n          var self = this;\n          this.showTimeout = setTimeout(function () {\n            self.itemActivate($a);\n          }, this.opts.showOnClick && $a.closest('ul').dataSM('level') == 1 ? 1 : this.opts.showTimeout);\n        }\n\n        this.$root.triggerHandler('mouseenter.smapi', $a[0]);\n      },\n      itemFocus: function itemFocus(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        } // fix (the mousedown check): in some browsers a tap/click produces consecutive focus + click events so we don't need to activate the item on focus\n\n\n        if (this.focusActivated && (!this.isTouchMode() || !$a.dataSM('mousedown')) && (!this.activatedItems.length || this.activatedItems[this.activatedItems.length - 1][0] != $a[0])) {\n          this.itemActivate($a, true);\n        }\n\n        this.$root.triggerHandler('focus.smapi', $a[0]);\n      },\n      itemLeave: function itemLeave(e) {\n        var $a = $(e.currentTarget);\n\n        if (!this.handleItemEvents($a)) {\n          return;\n        }\n\n        if (!this.isTouchMode()) {\n          $a[0].blur();\n\n          if (this.showTimeout) {\n            clearTimeout(this.showTimeout);\n            this.showTimeout = 0;\n          }\n        }\n\n        $a.removeDataSM('mousedown');\n        this.$root.triggerHandler('mouseleave.smapi', $a[0]);\n      },\n      menuHide: function menuHide($sub) {\n        if (this.$root.triggerHandler('beforehide.smapi', $sub[0]) === false) {\n          return;\n        }\n\n        if (canAnimate) {\n          $sub.stop(true, true);\n        }\n\n        if ($sub.css('display') != 'none') {\n          var complete = function complete() {\n            // unset z-index\n            $sub.css('z-index', '');\n          }; // if sub is collapsible (mobile view)\n\n\n          if (this.isCollapsible()) {\n            if (canAnimate && this.opts.collapsibleHideFunction) {\n              this.opts.collapsibleHideFunction.call(this, $sub, complete);\n            } else {\n              $sub.hide(this.opts.collapsibleHideDuration, complete);\n            }\n          } else {\n            if (canAnimate && this.opts.hideFunction) {\n              this.opts.hideFunction.call(this, $sub, complete);\n            } else {\n              $sub.hide(this.opts.hideDuration, complete);\n            }\n          } // deactivate scrolling if it is activated for this sub\n\n\n          if ($sub.dataSM('scroll')) {\n            this.menuScrollStop($sub);\n            $sub.css({\n              'touch-action': '',\n              '-ms-touch-action': '',\n              '-webkit-transform': '',\n              transform: ''\n            }).off('.smartmenus_scroll').removeDataSM('scroll').dataSM('scroll-arrows').hide();\n          } // unhighlight parent item + accessibility\n\n\n          $sub.dataSM('parent-a').removeClass('highlighted').attr('aria-expanded', 'false');\n          $sub.attr({\n            'aria-expanded': 'false',\n            'aria-hidden': 'true'\n          });\n          var level = $sub.dataSM('level');\n          this.activatedItems.splice(level - 1, 1);\n          this.visibleSubMenus.splice($.inArray($sub, this.visibleSubMenus), 1);\n          this.$root.triggerHandler('hide.smapi', $sub[0]);\n        }\n      },\n      menuHideAll: function menuHideAll() {\n        if (this.showTimeout) {\n          clearTimeout(this.showTimeout);\n          this.showTimeout = 0;\n        } // hide all subs\n        // if it's a popup, this.visibleSubMenus[0] is the root UL\n\n\n        var level = this.opts.isPopup ? 1 : 0;\n\n        for (var i = this.visibleSubMenus.length - 1; i >= level; i--) {\n          this.menuHide(this.visibleSubMenus[i]);\n        } // hide root if it's popup\n\n\n        if (this.opts.isPopup) {\n          if (canAnimate) {\n            this.$root.stop(true, true);\n          }\n\n          if (this.$root.is(':visible')) {\n            if (canAnimate && this.opts.hideFunction) {\n              this.opts.hideFunction.call(this, this.$root);\n            } else {\n              this.$root.hide(this.opts.hideDuration);\n            }\n          }\n        }\n\n        this.activatedItems = [];\n        this.visibleSubMenus = [];\n        this.clickActivated = false;\n        this.focusActivated = false; // reset z-index increment\n\n        this.zIndexInc = 0;\n        this.$root.triggerHandler('hideAll.smapi');\n      },\n      menuHideSubMenus: function menuHideSubMenus(level) {\n        for (var i = this.activatedItems.length - 1; i >= level; i--) {\n          var $sub = this.activatedItems[i].dataSM('sub');\n\n          if ($sub) {\n            this.menuHide($sub);\n          }\n        }\n      },\n      menuInit: function menuInit($ul) {\n        if (!$ul.dataSM('in-mega')) {\n          // mark UL's in mega drop downs (if any) so we can neglect them\n          if ($ul.hasClass('mega-menu')) {\n            $ul.find('ul').dataSM('in-mega', true);\n          } // get level (much faster than, for example, using parentsUntil)\n\n\n          var level = 2,\n              par = $ul[0];\n\n          while ((par = par.parentNode.parentNode) != this.$root[0]) {\n            level++;\n          } // cache stuff for quick access\n\n\n          var $a = $ul.prevAll('a').eq(-1); // if the link is nested (e.g. in a heading)\n\n          if (!$a.length) {\n            $a = $ul.prevAll().find('a').eq(-1);\n          }\n\n          $a.addClass('has-submenu').dataSM('sub', $ul);\n          $ul.dataSM('parent-a', $a).dataSM('level', level).parent().dataSM('sub', $ul); // accessibility\n\n          var aId = $a.attr('id') || this.accessIdPrefix + ++this.idInc,\n              ulId = $ul.attr('id') || this.accessIdPrefix + ++this.idInc;\n          $a.attr({\n            id: aId,\n            'aria-haspopup': 'true',\n            'aria-controls': ulId,\n            'aria-expanded': 'false'\n          });\n          $ul.attr({\n            id: ulId,\n            'role': 'group',\n            'aria-hidden': 'true',\n            'aria-labelledby': aId,\n            'aria-expanded': 'false'\n          }); // add sub indicator to parent item\n\n          if (this.opts.subIndicators) {\n            $a[this.opts.subIndicatorsPos](this.$subArrow.clone());\n          }\n        }\n      },\n      menuPosition: function menuPosition($sub) {\n        var $a = $sub.dataSM('parent-a'),\n            $li = $a.closest('li'),\n            $ul = $li.parent(),\n            level = $sub.dataSM('level'),\n            subW = this.getWidth($sub),\n            subH = this.getHeight($sub),\n            itemOffset = $a.offset(),\n            itemX = itemOffset.left,\n            itemY = itemOffset.top,\n            itemW = this.getWidth($a),\n            itemH = this.getHeight($a),\n            $win = $(window),\n            winX = $win.scrollLeft(),\n            winY = $win.scrollTop(),\n            winW = this.getViewportWidth(),\n            winH = this.getViewportHeight(),\n            horizontalParent = $ul.parent().is('[data-sm-horizontal-sub]') || level == 2 && !$ul.hasClass('sm-vertical'),\n            rightToLeft = this.opts.rightToLeftSubMenus && !$li.is('[data-sm-reverse]') || !this.opts.rightToLeftSubMenus && $li.is('[data-sm-reverse]'),\n            subOffsetX = level == 2 ? this.opts.mainMenuSubOffsetX : this.opts.subMenusSubOffsetX,\n            subOffsetY = level == 2 ? this.opts.mainMenuSubOffsetY : this.opts.subMenusSubOffsetY,\n            x,\n            y;\n\n        if (horizontalParent) {\n          x = rightToLeft ? itemW - subW - subOffsetX : subOffsetX;\n          y = this.opts.bottomToTopSubMenus ? -subH - subOffsetY : itemH + subOffsetY;\n        } else {\n          x = rightToLeft ? subOffsetX - subW : itemW - subOffsetX;\n          y = this.opts.bottomToTopSubMenus ? itemH - subOffsetY - subH : subOffsetY;\n        }\n\n        if (this.opts.keepInViewport) {\n          var absX = itemX + x,\n              absY = itemY + y;\n\n          if (rightToLeft && absX < winX) {\n            x = horizontalParent ? winX - absX + x : itemW - subOffsetX;\n          } else if (!rightToLeft && absX + subW > winX + winW) {\n            x = horizontalParent ? winX + winW - subW - absX + x : subOffsetX - subW;\n          }\n\n          if (!horizontalParent) {\n            if (subH < winH && absY + subH > winY + winH) {\n              y += winY + winH - subH - absY;\n            } else if (subH >= winH || absY < winY) {\n              y += winY - absY;\n            }\n          } // do we need scrolling?\n          // 0.49 used for better precision when dealing with float values\n\n\n          if (horizontalParent && (absY + subH > winY + winH + 0.49 || absY < winY) || !horizontalParent && subH > winH + 0.49) {\n            var self = this;\n\n            if (!$sub.dataSM('scroll-arrows')) {\n              $sub.dataSM('scroll-arrows', $([$('<span class=\"scroll-up\"><span class=\"scroll-up-arrow\"></span></span>')[0], $('<span class=\"scroll-down\"><span class=\"scroll-down-arrow\"></span></span>')[0]]).on({\n                mouseenter: function mouseenter() {\n                  $sub.dataSM('scroll').up = $(this).hasClass('scroll-up');\n                  self.menuScroll($sub);\n                },\n                mouseleave: function mouseleave(e) {\n                  self.menuScrollStop($sub);\n                  self.menuScrollOut($sub, e);\n                },\n                'mousewheel DOMMouseScroll': function mousewheelDOMMouseScroll(e) {\n                  e.preventDefault();\n                }\n              }).insertAfter($sub));\n            } // bind scroll events and save scroll data for this sub\n\n\n            var eNS = '.smartmenus_scroll';\n            $sub.dataSM('scroll', {\n              y: this.cssTransforms3d ? 0 : y - itemH,\n              step: 1,\n              // cache stuff for faster recalcs later\n              itemH: itemH,\n              subH: subH,\n              arrowDownH: this.getHeight($sub.dataSM('scroll-arrows').eq(1))\n            }).on(getEventsNS({\n              'mouseover': function mouseover(e) {\n                self.menuScrollOver($sub, e);\n              },\n              'mouseout': function mouseout(e) {\n                self.menuScrollOut($sub, e);\n              },\n              'mousewheel DOMMouseScroll': function mousewheelDOMMouseScroll(e) {\n                self.menuScrollMousewheel($sub, e);\n              }\n            }, eNS)).dataSM('scroll-arrows').css({\n              top: 'auto',\n              left: '0',\n              marginLeft: x + (parseInt($sub.css('border-left-width')) || 0),\n              width: subW - (parseInt($sub.css('border-left-width')) || 0) - (parseInt($sub.css('border-right-width')) || 0),\n              zIndex: $sub.css('z-index')\n            }).eq(horizontalParent && this.opts.bottomToTopSubMenus ? 0 : 1).show(); // when a menu tree is fixed positioned we allow scrolling via touch too\n            // since there is no other way to access such long sub menus if no mouse is present\n\n            if (this.isFixed()) {\n              var events = {};\n\n              events[touchEvents ? 'touchstart touchmove touchend' : 'pointerdown pointermove pointerup MSPointerDown MSPointerMove MSPointerUp'] = function (e) {\n                self.menuScrollTouch($sub, e);\n              };\n\n              $sub.css({\n                'touch-action': 'none',\n                '-ms-touch-action': 'none'\n              }).on(getEventsNS(events, eNS));\n            }\n          }\n        }\n\n        $sub.css({\n          top: 'auto',\n          left: '0',\n          marginLeft: x,\n          marginTop: y - itemH\n        });\n      },\n      menuScroll: function menuScroll($sub, once, step) {\n        var data = $sub.dataSM('scroll'),\n            $arrows = $sub.dataSM('scroll-arrows'),\n            end = data.up ? data.upEnd : data.downEnd,\n            diff;\n\n        if (!once && data.momentum) {\n          data.momentum *= 0.92;\n          diff = data.momentum;\n\n          if (diff < 0.5) {\n            this.menuScrollStop($sub);\n            return;\n          }\n        } else {\n          diff = step || (once || !this.opts.scrollAccelerate ? this.opts.scrollStep : Math.floor(data.step));\n        } // hide any visible deeper level sub menus\n\n\n        var level = $sub.dataSM('level');\n\n        if (this.activatedItems[level - 1] && this.activatedItems[level - 1].dataSM('sub') && this.activatedItems[level - 1].dataSM('sub').is(':visible')) {\n          this.menuHideSubMenus(level - 1);\n        }\n\n        data.y = data.up && end <= data.y || !data.up && end >= data.y ? data.y : Math.abs(end - data.y) > diff ? data.y + (data.up ? diff : -diff) : end;\n        $sub.css(this.cssTransforms3d ? {\n          '-webkit-transform': 'translate3d(0, ' + data.y + 'px, 0)',\n          transform: 'translate3d(0, ' + data.y + 'px, 0)'\n        } : {\n          marginTop: data.y\n        }); // show opposite arrow if appropriate\n\n        if (mouse && (data.up && data.y > data.downEnd || !data.up && data.y < data.upEnd)) {\n          $arrows.eq(data.up ? 1 : 0).show();\n        } // if we've reached the end\n\n\n        if (data.y == end) {\n          if (mouse) {\n            $arrows.eq(data.up ? 0 : 1).hide();\n          }\n\n          this.menuScrollStop($sub);\n        } else if (!once) {\n          if (this.opts.scrollAccelerate && data.step < this.opts.scrollStep) {\n            data.step += 0.2;\n          }\n\n          var self = this;\n          this.scrollTimeout = requestAnimationFrame(function () {\n            self.menuScroll($sub);\n          });\n        }\n      },\n      menuScrollMousewheel: function menuScrollMousewheel($sub, e) {\n        if (this.getClosestMenu(e.target) == $sub[0]) {\n          e = e.originalEvent;\n          var up = (e.wheelDelta || -e.detail) > 0;\n\n          if ($sub.dataSM('scroll-arrows').eq(up ? 0 : 1).is(':visible')) {\n            $sub.dataSM('scroll').up = up;\n            this.menuScroll($sub, true);\n          }\n        }\n\n        e.preventDefault();\n      },\n      menuScrollOut: function menuScrollOut($sub, e) {\n        if (mouse) {\n          if (!/^scroll-(up|down)/.test((e.relatedTarget || '').className) && ($sub[0] != e.relatedTarget && !$.contains($sub[0], e.relatedTarget) || this.getClosestMenu(e.relatedTarget) != $sub[0])) {\n            $sub.dataSM('scroll-arrows').css('visibility', 'hidden');\n          }\n        }\n      },\n      menuScrollOver: function menuScrollOver($sub, e) {\n        if (mouse) {\n          if (!/^scroll-(up|down)/.test(e.target.className) && this.getClosestMenu(e.target) == $sub[0]) {\n            this.menuScrollRefreshData($sub);\n            var data = $sub.dataSM('scroll'),\n                upEnd = $(window).scrollTop() - $sub.dataSM('parent-a').offset().top - data.itemH;\n            $sub.dataSM('scroll-arrows').eq(0).css('margin-top', upEnd).end().eq(1).css('margin-top', upEnd + this.getViewportHeight() - data.arrowDownH).end().css('visibility', 'visible');\n          }\n        }\n      },\n      menuScrollRefreshData: function menuScrollRefreshData($sub) {\n        var data = $sub.dataSM('scroll'),\n            upEnd = $(window).scrollTop() - $sub.dataSM('parent-a').offset().top - data.itemH;\n\n        if (this.cssTransforms3d) {\n          upEnd = -(parseFloat($sub.css('margin-top')) - upEnd);\n        }\n\n        $.extend(data, {\n          upEnd: upEnd,\n          downEnd: upEnd + this.getViewportHeight() - data.subH\n        });\n      },\n      menuScrollStop: function menuScrollStop($sub) {\n        if (this.scrollTimeout) {\n          cancelAnimationFrame(this.scrollTimeout);\n          this.scrollTimeout = 0;\n          $sub.dataSM('scroll').step = 1;\n          return true;\n        }\n      },\n      menuScrollTouch: function menuScrollTouch($sub, e) {\n        e = e.originalEvent;\n\n        if (isTouchEvent(e)) {\n          var touchPoint = this.getTouchPoint(e); // neglect event if we touched a visible deeper level sub menu\n\n          if (this.getClosestMenu(touchPoint.target) == $sub[0]) {\n            var data = $sub.dataSM('scroll');\n\n            if (/(start|down)$/i.test(e.type)) {\n              if (this.menuScrollStop($sub)) {\n                // if we were scrolling, just stop and don't activate any link on the first touch\n                e.preventDefault();\n                this.$touchScrollingSub = $sub;\n              } else {\n                this.$touchScrollingSub = null;\n              } // update scroll data since the user might have zoomed, etc.\n\n\n              this.menuScrollRefreshData($sub); // extend it with the touch properties\n\n              $.extend(data, {\n                touchStartY: touchPoint.pageY,\n                touchStartTime: e.timeStamp\n              });\n            } else if (/move$/i.test(e.type)) {\n              var prevY = data.touchY !== undefined ? data.touchY : data.touchStartY;\n\n              if (prevY !== undefined && prevY != touchPoint.pageY) {\n                this.$touchScrollingSub = $sub;\n                var up = prevY < touchPoint.pageY; // changed direction? reset...\n\n                if (data.up !== undefined && data.up != up) {\n                  $.extend(data, {\n                    touchStartY: touchPoint.pageY,\n                    touchStartTime: e.timeStamp\n                  });\n                }\n\n                $.extend(data, {\n                  up: up,\n                  touchY: touchPoint.pageY\n                });\n                this.menuScroll($sub, true, Math.abs(touchPoint.pageY - prevY));\n              }\n\n              e.preventDefault();\n            } else {\n              // touchend/pointerup\n              if (data.touchY !== undefined) {\n                if (data.momentum = Math.pow(Math.abs(touchPoint.pageY - data.touchStartY) / (e.timeStamp - data.touchStartTime), 2) * 15) {\n                  this.menuScrollStop($sub);\n                  this.menuScroll($sub);\n                  e.preventDefault();\n                }\n\n                delete data.touchY;\n              }\n            }\n          }\n        }\n      },\n      menuShow: function menuShow($sub) {\n        if (!$sub.dataSM('beforefirstshowfired')) {\n          $sub.dataSM('beforefirstshowfired', true);\n\n          if (this.$root.triggerHandler('beforefirstshow.smapi', $sub[0]) === false) {\n            return;\n          }\n        }\n\n        if (this.$root.triggerHandler('beforeshow.smapi', $sub[0]) === false) {\n          return;\n        }\n\n        $sub.dataSM('shown-before', true);\n\n        if (canAnimate) {\n          $sub.stop(true, true);\n        }\n\n        if (!$sub.is(':visible')) {\n          // highlight parent item\n          var $a = $sub.dataSM('parent-a'),\n              collapsible = this.isCollapsible();\n\n          if (this.opts.keepHighlighted || collapsible) {\n            $a.addClass('highlighted');\n          }\n\n          if (collapsible) {\n            $sub.removeClass('sm-nowrap').css({\n              zIndex: '',\n              width: 'auto',\n              minWidth: '',\n              maxWidth: '',\n              top: '',\n              left: '',\n              marginLeft: '',\n              marginTop: ''\n            });\n          } else {\n            // set z-index\n            $sub.css('z-index', this.zIndexInc = (this.zIndexInc || this.getStartZIndex()) + 1); // min/max-width fix - no way to rely purely on CSS as all UL's are nested\n\n            if (this.opts.subMenusMinWidth || this.opts.subMenusMaxWidth) {\n              $sub.css({\n                width: 'auto',\n                minWidth: '',\n                maxWidth: ''\n              }).addClass('sm-nowrap');\n\n              if (this.opts.subMenusMinWidth) {\n                $sub.css('min-width', this.opts.subMenusMinWidth);\n              }\n\n              if (this.opts.subMenusMaxWidth) {\n                var noMaxWidth = this.getWidth($sub);\n                $sub.css('max-width', this.opts.subMenusMaxWidth);\n\n                if (noMaxWidth > this.getWidth($sub)) {\n                  $sub.removeClass('sm-nowrap').css('width', this.opts.subMenusMaxWidth);\n                }\n              }\n            }\n\n            this.menuPosition($sub);\n          }\n\n          var complete = function complete() {\n            // fix: \"overflow: hidden;\" is not reset on animation complete in jQuery < 1.9.0 in Chrome when global \"box-sizing: border-box;\" is used\n            $sub.css('overflow', '');\n          }; // if sub is collapsible (mobile view)\n\n\n          if (collapsible) {\n            if (canAnimate && this.opts.collapsibleShowFunction) {\n              this.opts.collapsibleShowFunction.call(this, $sub, complete);\n            } else {\n              $sub.show(this.opts.collapsibleShowDuration, complete);\n            }\n          } else {\n            if (canAnimate && this.opts.showFunction) {\n              this.opts.showFunction.call(this, $sub, complete);\n            } else {\n              $sub.show(this.opts.showDuration, complete);\n            }\n          } // accessibility\n\n\n          $a.attr('aria-expanded', 'true');\n          $sub.attr({\n            'aria-expanded': 'true',\n            'aria-hidden': 'false'\n          }); // store sub menu in visible array\n\n          this.visibleSubMenus.push($sub);\n          this.$root.triggerHandler('show.smapi', $sub[0]);\n        }\n      },\n      popupHide: function popupHide(noHideTimeout) {\n        if (this.hideTimeout) {\n          clearTimeout(this.hideTimeout);\n          this.hideTimeout = 0;\n        }\n\n        var self = this;\n        this.hideTimeout = setTimeout(function () {\n          self.menuHideAll();\n        }, noHideTimeout ? 1 : this.opts.hideTimeout);\n      },\n      popupShow: function popupShow(left, top) {\n        if (!this.opts.isPopup) {\n          alert('SmartMenus jQuery Error:\\n\\nIf you want to show this menu via the \"popupShow\" method, set the isPopup:true option.');\n          return;\n        }\n\n        if (this.hideTimeout) {\n          clearTimeout(this.hideTimeout);\n          this.hideTimeout = 0;\n        }\n\n        this.$root.dataSM('shown-before', true);\n\n        if (canAnimate) {\n          this.$root.stop(true, true);\n        }\n\n        if (!this.$root.is(':visible')) {\n          this.$root.css({\n            left: left,\n            top: top\n          }); // show menu\n\n          var self = this,\n              complete = function complete() {\n            self.$root.css('overflow', '');\n          };\n\n          if (canAnimate && this.opts.showFunction) {\n            this.opts.showFunction.call(this, this.$root, complete);\n          } else {\n            this.$root.show(this.opts.showDuration, complete);\n          }\n\n          this.visibleSubMenus[0] = this.$root;\n        }\n      },\n      refresh: function refresh() {\n        this.destroy(true);\n        this.init(true);\n      },\n      rootKeyDown: function rootKeyDown(e) {\n        if (!this.handleEvents()) {\n          return;\n        }\n\n        switch (e.keyCode) {\n          case 27:\n            // reset on Esc\n            var $activeTopItem = this.activatedItems[0];\n\n            if ($activeTopItem) {\n              this.menuHideAll();\n              $activeTopItem[0].focus();\n              var $sub = $activeTopItem.dataSM('sub');\n\n              if ($sub) {\n                this.menuHide($sub);\n              }\n            }\n\n            break;\n\n          case 32:\n            // activate item's sub on Space\n            var $target = $(e.target);\n\n            if ($target.is('a') && this.handleItemEvents($target)) {\n              var $sub = $target.dataSM('sub');\n\n              if ($sub && !$sub.is(':visible')) {\n                this.itemClick({\n                  currentTarget: e.target\n                });\n                e.preventDefault();\n              }\n            }\n\n            break;\n        }\n      },\n      rootOut: function rootOut(e) {\n        if (!this.handleEvents() || this.isTouchMode() || e.target == this.$root[0]) {\n          return;\n        }\n\n        if (this.hideTimeout) {\n          clearTimeout(this.hideTimeout);\n          this.hideTimeout = 0;\n        }\n\n        if (!this.opts.showOnClick || !this.opts.hideOnClick) {\n          var self = this;\n          this.hideTimeout = setTimeout(function () {\n            self.menuHideAll();\n          }, this.opts.hideTimeout);\n        }\n      },\n      rootOver: function rootOver(e) {\n        if (!this.handleEvents() || this.isTouchMode() || e.target == this.$root[0]) {\n          return;\n        }\n\n        if (this.hideTimeout) {\n          clearTimeout(this.hideTimeout);\n          this.hideTimeout = 0;\n        }\n      },\n      winResize: function winResize(e) {\n        if (!this.handleEvents()) {\n          // we still need to resize the disable overlay if it's visible\n          if (this.$disableOverlay) {\n            var pos = this.$root.offset();\n            this.$disableOverlay.css({\n              top: pos.top,\n              left: pos.left,\n              width: this.$root.outerWidth(),\n              height: this.$root.outerHeight()\n            });\n          }\n\n          return;\n        } // hide sub menus on resize - on mobile do it only on orientation change\n\n\n        if (!('onorientationchange' in window) || e.type == 'orientationchange') {\n          var collapsible = this.isCollapsible(); // if it was collapsible before resize and still is, don't do it\n\n          if (!(this.wasCollapsible && collapsible)) {\n            if (this.activatedItems.length) {\n              this.activatedItems[this.activatedItems.length - 1][0].blur();\n            }\n\n            this.menuHideAll();\n          }\n\n          this.wasCollapsible = collapsible;\n        }\n      }\n    }\n  });\n\n  $.fn.dataSM = function (key, val) {\n    if (val) {\n      return this.data(key + '_smartmenus', val);\n    }\n\n    return this.data(key + '_smartmenus');\n  };\n\n  $.fn.removeDataSM = function (key) {\n    return this.removeData(key + '_smartmenus');\n  };\n\n  $.fn.smartmenus = function (options) {\n    if (typeof options == 'string') {\n      var args = arguments,\n          method = options;\n      Array.prototype.shift.call(args);\n      return this.each(function () {\n        var smartmenus = $(this).data('smartmenus');\n\n        if (smartmenus && smartmenus[method]) {\n          smartmenus[method].apply(smartmenus, args);\n        }\n      });\n    }\n\n    return this.each(function () {\n      // [data-sm-options] attribute on the root UL\n      var dataOpts = $(this).data('sm-options') || null;\n\n      if (dataOpts) {\n        try {\n          dataOpts = eval('(' + dataOpts + ')');\n        } catch (e) {\n          dataOpts = null;\n          alert('ERROR\\n\\nSmartMenus jQuery init:\\nInvalid \"data-sm-options\" attribute value syntax.');\n        }\n\n        ;\n      }\n\n      new $.SmartMenus(this, $.extend({}, $.fn.smartmenus.defaults, options, dataOpts));\n    });\n  }; // default settings\n\n\n  $.fn.smartmenus.defaults = {\n    isPopup: false,\n    // is this a popup menu (can be shown via the popupShow/popupHide methods) or a permanent menu bar\n    mainMenuSubOffsetX: 0,\n    // pixels offset from default position\n    mainMenuSubOffsetY: 0,\n    // pixels offset from default position\n    subMenusSubOffsetX: 0,\n    // pixels offset from default position\n    subMenusSubOffsetY: 0,\n    // pixels offset from default position\n    subMenusMinWidth: '10em',\n    // min-width for the sub menus (any CSS unit) - if set, the fixed width set in CSS will be ignored\n    subMenusMaxWidth: '20em',\n    // max-width for the sub menus (any CSS unit) - if set, the fixed width set in CSS will be ignored\n    subIndicators: true,\n    // create sub menu indicators - creates a SPAN and inserts it in the A\n    subIndicatorsPos: 'append',\n    // position of the SPAN relative to the menu item content ('append', 'prepend')\n    subIndicatorsText: '',\n    // [optionally] add text in the SPAN (e.g. '+') (you may want to check the CSS for the sub indicators too)\n    scrollStep: 30,\n    // pixels step when scrolling long sub menus that do not fit in the viewport height\n    scrollAccelerate: true,\n    // accelerate scrolling or use a fixed step\n    showTimeout: 250,\n    // timeout before showing the sub menus\n    hideTimeout: 500,\n    // timeout before hiding the sub menus\n    showDuration: 0,\n    // duration for show animation - set to 0 for no animation - matters only if showFunction:null\n    showFunction: null,\n    // custom function to use when showing a sub menu (the default is the jQuery 'show')\n    // don't forget to call complete() at the end of whatever you do\n    // e.g.: function($ul, complete) { $ul.fadeIn(250, complete); }\n    hideDuration: 0,\n    // duration for hide animation - set to 0 for no animation - matters only if hideFunction:null\n    hideFunction: function hideFunction($ul, complete) {\n      $ul.fadeOut(200, complete);\n    },\n    // custom function to use when hiding a sub menu (the default is the jQuery 'hide')\n    // don't forget to call complete() at the end of whatever you do\n    // e.g.: function($ul, complete) { $ul.fadeOut(250, complete); }\n    collapsibleShowDuration: 0,\n    // duration for show animation for collapsible sub menus - matters only if collapsibleShowFunction:null\n    collapsibleShowFunction: function collapsibleShowFunction($ul, complete) {\n      $ul.slideDown(200, complete);\n    },\n    // custom function to use when showing a collapsible sub menu\n    // (i.e. when mobile styles are used to make the sub menus collapsible)\n    collapsibleHideDuration: 0,\n    // duration for hide animation for collapsible sub menus - matters only if collapsibleHideFunction:null\n    collapsibleHideFunction: function collapsibleHideFunction($ul, complete) {\n      $ul.slideUp(200, complete);\n    },\n    // custom function to use when hiding a collapsible sub menu\n    // (i.e. when mobile styles are used to make the sub menus collapsible)\n    showOnClick: false,\n    // show the first-level sub menus onclick instead of onmouseover (i.e. mimic desktop app menus) (matters only for mouse input)\n    hideOnClick: true,\n    // hide the sub menus on click/tap anywhere on the page\n    noMouseOver: false,\n    // disable sub menus activation onmouseover (i.e. behave like in touch mode - use just mouse clicks) (matters only for mouse input)\n    keepInViewport: true,\n    // reposition the sub menus if needed to make sure they always appear inside the viewport\n    keepHighlighted: true,\n    // keep all ancestor items of the current sub menu highlighted (adds the 'highlighted' class to the A's)\n    markCurrentItem: false,\n    // automatically add the 'current' class to the A element of the item linking to the current URL\n    markCurrentTree: true,\n    // add the 'current' class also to the A elements of all ancestor items of the current item\n    rightToLeftSubMenus: false,\n    // right to left display of the sub menus (check the CSS for the sub indicators' position)\n    bottomToTopSubMenus: false,\n    // bottom to top display of the sub menus\n    collapsibleBehavior: 'default' // parent items behavior in collapsible (mobile) view ('default', 'toggle', 'link', 'accordion', 'accordion-toggle', 'accordion-link')\n    // 'default' - first tap on parent item expands sub, second tap loads its link\n    // 'toggle' - the whole parent item acts just as a toggle button for its sub menu (expands/collapses on each tap)\n    // 'link' - the parent item acts as a regular item (first tap loads its link), the sub menu can be expanded only via the +/- button\n    // 'accordion' - like 'default' but on expand also resets any visible sub menus from deeper levels or other branches\n    // 'accordion-toggle' - like 'toggle' but on expand also resets any visible sub menus from deeper levels or other branches\n    // 'accordion-link' - like 'link' but on expand also resets any visible sub menus from deeper levels or other branches\n\n  };\n  return $;\n});","map":null,"metadata":{},"sourceType":"script"}